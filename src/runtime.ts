/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by DANA Indonesia.
 * Do not edit the class manually.
 */


import { createHash, createSign, constants as cryptoConstants } from 'node:crypto';
import { format } from 'date-fns-tz';
import { v4 as uuidv4 } from 'uuid';

export const BASE_PATH = "https://api.saas.dana.id".replace(/\/+$/, "");

export const Env = {
    SANDBOX: 'sandbox',
    PRODUCTION: 'production'
};

export interface ConfigurationParameters {
    basePath?: string; // override base path
    fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    apiKey?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters = {}) {}

    set config(configuration: Configuration) {
        this.configuration = configuration;
    }

    get basePath(): string {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }

    get fetchApi(): FetchAPI | undefined {
        return this.configuration.fetchApi;
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get apiKey(): ((name: string) => string | Promise<string>) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get credentials(): RequestCredentials | undefined {
        return this.configuration.credentials;
    }
}

export const DefaultConfig = new Configuration();

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    private static readonly jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
    private middleware: Middleware[];

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    protected isJsonMime(mime: string | null | undefined): boolean {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        let errorResponse;
        try {
            errorResponse = await response.json();
        } catch (e) {
            errorResponse = await response.text();
        }
        throw new ResponseError(errorResponse, response.status, response.statusText);
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        let body: any;
        if (isFormData(overriddenInit.body)
            || (overriddenInit.body instanceof URLSearchParams)
            || isBlob(overriddenInit.body)) {
          body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
          body = JSON.stringify(overriddenInit.body);
        } else {
          body = overriddenInit.body;
        }

        const init: RequestInit = {
            ...overriddenInit,
            body
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        let response: Response | undefined = undefined;
        try {
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    response = await middleware.onError({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

export class ResponseError extends Error {
    override name: "ResponseError" = "ResponseError";
    rawResponse?: any;
    status: string;
    errorCode?: string;
    errorMessage?: string;
    constructor(private response: any, status, statusText) {
        super(`[DANA SDK Error] ${status} ${statusText}`);
        this.rawResponse = response;
        this.status = status || this.rawResponse?.status || this.rawResponse?.status_code || this.rawResponse?.statusCode;
        this.errorCode = this.rawResponse?.error || this.rawResponse?.error_code || this.rawResponse?.errorCode;
        this.errorMessage = this.rawResponse?.message || this.rawResponse?.error_message || this.rawResponse?.errorMessage || statusText;
    }
}

export class FetchError extends Error {
    override name: "FetchError" = "FetchError";
    constructor(public cause: Error, msg?: string) {
        super(msg);
    }
}

export class RequiredError extends Error {
    override name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export class ValidationError extends Error {
    override name: "ValidationError" = "ValidationError";
    constructor(public validationErrorContexts: ValidationErrorContext[]) {
        super(ValidationUtil.getValidationErrorMessage(validationErrorContexts));
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody };
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function getBasePathByEnv(env: string): string {
    switch (env) {
        case 'production':
            return 'https://api.saas.dana.id';
        case 'sandbox':
            return 'https://api.sandbox.dana.id';
        default:
            throw new Error(
                `Invalid env value provided: '${env}'. Allowed values are 'production' or 'sandbox'.`
            );
    }
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}

function querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value as HTTPQuery, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string;
}

export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}

export interface PropertyValidationAttribute {
    maxLength?: number,
    minLength?: number,
    pattern?: RegExp,
    maximum?: number,
    exclusiveMaximum?: boolean,
    minimum?: number,
    exclusiveMinimum?: boolean,
    multipleOf?: number,
    maxItems?: number,
    minItems?: number,
    uniqueItems?: boolean,
    maxDate?: string
};

export interface ValidationErrorContext {
    field: string;
    message: string;
}

export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}

export class ValidationUtil {
    /**
     * Validates a property against a set of validation attributes.
     * @param field - The name of the field being validated.
     * @param value - The value of the field to validate.
     * @param attribute - The validation attributes to apply.
     * @returns An array of `ValidationErrorContext` objects describing the validation errors.
     */
    static validateProperty(field: string, value: any, attribute: PropertyValidationAttribute): ValidationErrorContext[] {
        const validationErrorContexts: ValidationErrorContext[] = [];
    
        if (value == null) {
            return validationErrorContexts;
        }
    
        if (typeof value === 'string') {
            if (attribute.maxLength !== undefined && value.length > attribute.maxLength) {
                validationErrorContexts.push({ field, message: `must be at most ${attribute.maxLength} characters long` });
            }
            if (attribute.minLength !== undefined && value.length < attribute.minLength) {
                validationErrorContexts.push({ field, message: `must be at least ${attribute.minLength} characters long` });
            }
            if (attribute.pattern && !attribute.pattern.test(value)) {
                validationErrorContexts.push({ field, message: 'must match required pattern' });
            }
            if (attribute.maxDate && attribute.maxDate === 'week') {
                try {
                    // Create current date in Jakarta timezone (GMT+7)
                    const currentDate = new Date();
                    // Add 7 hours to get Jakarta time
                    currentDate.setHours(currentDate.getHours() + 7);
                    
                    // Maximum allowed date (current date + 7 days)
                    const maxDate = new Date(currentDate);
                    maxDate.setDate(maxDate.getDate() + 7);
                    
                    // Parse the input date (assuming it's in ISO 8601 format)
                    const inputDate = new Date(value);
                    
                    // Check if the input date exceeds the maximum allowed date
                    if (inputDate > maxDate) {
                        validationErrorContexts.push({ 
                            field, 
                            message: 'date cannot be more than one week in the future' 
                        });
                    }
                } catch (error) {
                    validationErrorContexts.push({ 
                        field, 
                        message: 'invalid date format' 
                    });
                }
            }
        }
    
        if (typeof value === 'number') {
            if (attribute.maximum !== undefined && value > attribute.maximum) {
                validationErrorContexts.push({ field, message: `must be less than or equal to ${attribute.maximum}` });
            }
            if (attribute.exclusiveMaximum && value >= attribute.maximum!) {
                validationErrorContexts.push({ field, message: `must be less than ${attribute.maximum}` });
            }
            if (attribute.minimum !== undefined && value < attribute.minimum) {
                validationErrorContexts.push({ field, message: `must be greater than or equal to ${attribute.minimum}` });
            }
            if (attribute.exclusiveMinimum && value <= attribute.minimum!) {
                validationErrorContexts.push({ field, message: `must be greater than ${attribute.minimum}` });
            }
            if (attribute.multipleOf !== undefined && value % attribute.multipleOf !== 0) {
                validationErrorContexts.push({ field, message: `must be a multiple of ${attribute.multipleOf}` });
            }
        }
    
        if (Array.isArray(value)) {
            if (attribute.maxItems !== undefined && value.length > attribute.maxItems) {
                validationErrorContexts.push({ field, message: `must have at most ${attribute.maxItems} items` });
            }
            if (attribute.minItems !== undefined && value.length < attribute.minItems) {
                validationErrorContexts.push({ field, message: `must have at least ${attribute.minItems} items` });
            }
            if (attribute.uniqueItems) {
                const unique = new Set(value);
                if (unique.size !== value.length) {
                    validationErrorContexts.push({ field, message: 'must have unique items' });
                }
            }
        }
    
        return validationErrorContexts;
    }
    
    static getValidationErrorMessage(validationErrorContexts: ValidationErrorContext[]): string {
        return validationErrorContexts.map((validationErrorContext) => {
            return `${validationErrorContext.field} ${validationErrorContext.message}`;
        }).join(', ');
    }
}

export class DanaHeaderUtil {
    /**
     * Populates the HTTP headers required for the Snap B2B scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param httpMethod - The HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as a string.
     * @param privateKey - The private key used for generating the signature.
     * @param origin - The origin of the request.
     * @param partnerId - The partner ID.
     */
    static populateSnapB2BScenarioHeader(headerParameters: HTTPHeaders, httpMethod: string, endpointUrl: string, requestBody: string, privateKey: string, origin: string, partnerId: string): void {
        const timestamp: string = format(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        const signature = DanaSignatureUtil.generateSnapB2BScenarioSignature(httpMethod, endpointUrl, requestBody, privateKey, timestamp);

        headerParameters['X-TIMESTAMP'] = timestamp;
        headerParameters['X-SIGNATURE'] = signature;
        headerParameters['ORIGIN'] = origin;
        headerParameters['X-PARTNER-ID'] = partnerId;
        headerParameters['X-EXTERNAL-ID'] = uuidv4();
        headerParameters['CHANNEL-ID'] = partnerId + '-SERVER';
    }

    /**
     * Populates the HTTP headers required for the Snap B2B scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param httpMethod - The HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as object
     * @param privateKey - The private key used for generating the signature.
     * @param clientSecret - The client secret used for generating the signature.
     * @param partnerId - The partner ID.
     * @param functionName - The function name.
     */
    static populateOpenApiScenarioHeader(headerParameters: HTTPHeaders, httpMethod: string, endpointUrl: string, requestBody: Record<string,any>, privateKey: string, clientSecret: string, partnerId: string, functionName: string): void {
        const timestamp: string = format(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        
        requestBody['request']['head'] = {
            'version': "2.0",
            'function': functionName,
            'clientId': partnerId,
            'clientSecret': clientSecret,
            'reqTime': timestamp,
            'reqMsgId': uuidv4(),
            'reserve': {}
        }
        const signature = DanaSignatureUtil.generateOpenApiScenarioSignature(privateKey, JSON.stringify(requestBody["request"]));
        requestBody['signature'] = signature;
    }

    /**
     * Populates the HTTP headers required for the Snap Apply Token scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param privateKey - The private key used for generating the signature.
     * @param partnerId - The partner ID.
     */
    static populateSnapApplyTokenScenarioHeader(headerParameters: HTTPHeaders, privateKey: string, partnerId: string): void {
        const timestamp: string = format(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        const signature = DanaSignatureUtil.generateSnapApplyTokenScenarioSignature(partnerId, privateKey, timestamp);

        headerParameters['X-TIMESTAMP'] = timestamp;
        headerParameters['X-CLIENT-KEY'] = partnerId;
        headerParameters['X-SIGNATURE'] = signature;
    }

    /**
     * Populates the HTTP headers required for the Snap Account B2B2C scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param httpMethod - The HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as a string.
     * @param privateKey - The private key used for generating the signature.
     * @param origin - The origin of the request.
     * @param partnerId - The partner ID.
     * @param accessToken - The access token.
     * @param endUserIpAddress - The end user IP address.
     * @param deviceId - The device ID.
     * @param latitude - The latitude.
     * @param longitude - The longitude.
     */
    static populateSnapAccountB2B2CScenarioHeader(headerParameters: HTTPHeaders, httpMethod: string, endpointUrl: string, requestBody: string, privateKey: string, origin: string, partnerId: string, accessToken: string, endUserIpAddress: string, deviceId: string, latitude: string, longitude: string): void {
        const timestamp: string = format(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        const signature = DanaSignatureUtil.generateSnapB2BScenarioSignature(httpMethod, endpointUrl, requestBody, privateKey, timestamp);

        headerParameters['Authorization-Customer'] = accessToken.startsWith('Bearer ') ? accessToken : `Bearer ${accessToken}`;
        headerParameters['X-TIMESTAMP'] = timestamp;
        headerParameters['X-SIGNATURE'] = signature;
        headerParameters['ORIGIN'] = origin;
        headerParameters['X-PARTNER-ID'] = partnerId;
        headerParameters['X-EXTERNAL-ID'] = uuidv4();
        headerParameters['X-IP-ADDRESS'] = endUserIpAddress;
        headerParameters['X-DEVICE-ID'] = deviceId;
        headerParameters['X-LATITUDE'] = latitude;
        headerParameters['X-LONGITUDE'] = longitude;
        headerParameters['CHANNEL-ID'] = partnerId + '-SERVER';
    }
}

export class DanaSignatureUtil {
    /**
     * Generates a signature for the Snap B2B scenario.
     * @param httpMethod - HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as a string.
     * @param privateKey - The private key used for generating the signature.
     * @param timestamp - The timestamp for the signature.
     * @returns The Base64-encoded signature.
     */
    static generateSnapB2BScenarioSignature(httpMethod: string, endpointUrl: string, requestBody: string, privateKey: string, timestamp: string): string {
        // Generate a SHA-256 hash of the request body
        const hash: string = createHash('sha256')
            .update(requestBody)
            .digest('hex');

        // Construct the string to sign
        const stringToSign: string = `${httpMethod}:${endpointUrl}:${hash}:${timestamp}`;

        return this.generateAsymmetricSignature(stringToSign, privateKey);
    }

    /**
     * Generates a signature for the Snap Apply Token scenario.
     * @param partnerId - The partner ID.
     * @param privateKey - The private key used for generating the signature.
     * @param timestamp - The timestamp for the signature.
     * @returns The Base64-encoded signature.
     */
    static generateSnapApplyTokenScenarioSignature(partnerId: string, privateKey: string, timestamp: string): string {
        // Construct the string to sign
        const stringToSign: string = `${partnerId}|${timestamp}`;

        return this.generateAsymmetricSignature(stringToSign, privateKey);
    }
    
    static generateOpenApiScenarioSignature(privateKey: string, requestBody: string) {
        return this.generateAsymmetricSignature(requestBody, privateKey)
    }

    /**
     * Generates the seamlessSign for Oauth Url
     * @param seamlessData The data object to be signed
     * @param privateKey The private key for signing
     * @returns URL-encoded signature string
     */
    static generateSeamlessSign(seamlessData: object, privateKey: string): string {
        if (!seamlessData) {
            return '';
        }
        
        if (!privateKey) {
            throw new RequiredError('generateSeamlessSign', 'Private key is required');
        }
        
        try {
            const seamlessDataStr = JSON.stringify(seamlessData);
            
            const signer = createSign('RSA-SHA256');
            signer.update(seamlessDataStr);
            const signature = signer.sign({
                key: this.convertToPEM(privateKey, 'PRIVATE'),
                padding: cryptoConstants.RSA_PKCS1_PADDING,
            });
            
            const base64Signature = signature.toString('base64');
            
            return encodeURIComponent(base64Signature);
        } catch (error) {
            throw new Error(`Failed to calculate seamlessSign: ${error.message}`);
        }
    }

    /**
     * Generates an asymmetric signature.
     * @param stringToSign - The string to sign.
     * @param privateKey - The private key used for generating the signature.
     * @returns The Base64-encoded signature.
     */
    private static generateAsymmetricSignature(stringToSign: string, privateKey: string): string {
        // Create an RSA-SHA256 signer and sign the string
        const sign: ReturnType<typeof createSign> = createSign('RSA-SHA256');
        sign.update(stringToSign);
        sign.end();

        // Convert the private key to PEM format and sign the string
        const pemKey: string = this.convertToPEM(privateKey, 'PRIVATE');
        return sign.sign(pemKey, 'base64');
    }

    /**
     * Converts a private/public key to PEM format.
     * @param key - The key.
     * @param keyType - The type of key (e.g., PRIVATE, PUBLIC).
     * @returns The PEM-formatted key.
     */
    private static convertToPEM(key: string, keyType: string): string {
        const header: string = `-----BEGIN ${keyType} KEY-----`;
        const footer: string = `-----END ${keyType} KEY-----`;
        const delimiter: string = '\n';

        // Check if the key is already in PEM format
        if (key.includes(header) && key.includes(footer)) {
            return key.replace(/\\n/g, delimiter);
        }

        key = key.replace(/\\n/g, '');

        const chunks: string[] = [];
        for (let i = 0; i < key.length; i += 64) {
            const end = Math.min(i + 64, key.length);
            chunks.push(key.slice(i, end));
        }

        const body: string = chunks.join(delimiter);

        return header + delimiter + body + delimiter + footer;
    }

    /**
     * Splits a string into chunks of a specified size.
     * @param input - The input string.
     * @param chunkSize - The size of each chunk.
     * @returns An array of string chunks.
     */
    private static splitStringIntoChunks(input: string, chunkSize: number): string[] {
        const chunks: string[] = [];
        for (let i = 0; i < input.length; i += chunkSize) {
            chunks.push(input.slice(i, i + chunkSize));
        }
        return chunks;
    }
}