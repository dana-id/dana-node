"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by DANA Indonesia.
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DanaSignatureUtil = exports.DanaHeaderUtil = exports.ValidationUtil = exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.COLLECTION_FORMATS = exports.ValidationError = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.Env = exports.BASE_PATH = void 0;
exports.getBasePathByEnv = getBasePathByEnv;
exports.querystring = querystring;
exports.exists = exists;
exports.mapValues = mapValues;
exports.canConsumeForm = canConsumeForm;
const node_crypto_1 = require("node:crypto");
const date_fns_tz_1 = require("date-fns-tz");
const uuid_1 = require("uuid");
exports.BASE_PATH = "https://api.saas.dana.id".replace(/\/+$/, "");
exports.Env = {
    SANDBOX: 'sandbox',
    PRODUCTION: 'production'
};
class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
exports.DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
    constructor(configuration = exports.DefaultConfig) {
        this.configuration = configuration;
        this.fetchApi = async (url, init) => {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = await middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams)) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            }
            catch (e) {
                for (const middleware of this.middleware) {
                    if (middleware.onError) {
                        response = await middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined,
                        }) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    }
                    else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = await middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone(),
                    }) || response;
                }
            }
            return response;
        };
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        let errorResponse;
        try {
            errorResponse = await response.json();
        }
        catch (e) {
            errorResponse = await response.text();
        }
        throw new ResponseError(errorResponse, response.status, response.statusText);
    }
    async createFetchParams(context, initOverrides) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function"
            ? initOverrides
            : async () => initOverrides;
        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };
        const overriddenInit = Object.assign(Object.assign({}, initParams), (await initOverrideFn({
            init: initParams,
            context,
        })));
        let body;
        if (isFormData(overriddenInit.body)
            || (overriddenInit.body instanceof URLSearchParams)
            || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        }
        else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        }
        else {
            body = overriddenInit.body;
        }
        const init = Object.assign(Object.assign({}, overriddenInit), { body });
        return { url, init };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, status, statusText) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        super(`[DANA SDK Error] ${status} ${statusText}`);
        this.response = response;
        this.name = "ResponseError";
        this.rawResponse = response;
        this.status = status || ((_a = this.rawResponse) === null || _a === void 0 ? void 0 : _a.status) || ((_b = this.rawResponse) === null || _b === void 0 ? void 0 : _b.status_code) || ((_c = this.rawResponse) === null || _c === void 0 ? void 0 : _c.statusCode);
        this.errorCode = ((_d = this.rawResponse) === null || _d === void 0 ? void 0 : _d.error) || ((_e = this.rawResponse) === null || _e === void 0 ? void 0 : _e.error_code) || ((_f = this.rawResponse) === null || _f === void 0 ? void 0 : _f.errorCode);
        this.errorMessage = ((_g = this.rawResponse) === null || _g === void 0 ? void 0 : _g.message) || ((_h = this.rawResponse) === null || _h === void 0 ? void 0 : _h.error_message) || ((_j = this.rawResponse) === null || _j === void 0 ? void 0 : _j.errorMessage) || statusText;
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
class ValidationError extends Error {
    constructor(validationErrorContexts) {
        super(ValidationUtil.getValidationErrorMessage(validationErrorContexts));
        this.validationErrorContexts = validationErrorContexts;
        this.name = "ValidationError";
    }
}
exports.ValidationError = ValidationError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
function getBasePathByEnv(env) {
    switch (env) {
        case 'production':
            return 'https://api.saas.dana.id';
        case 'sandbox':
            return 'https://api.sandbox.dana.id';
        default:
            throw new Error(`Invalid env value provided: '${env}'. Allowed values are 'production' or 'sandbox'.`);
    }
}
function querystring(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: fn(data[key]) })), {});
}
function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
    ;
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
    ;
}
exports.TextApiResponse = TextApiResponse;
class ValidationUtil {
    /**
     * Validates a property against a set of validation attributes.
     * @param field - The name of the field being validated.
     * @param value - The value of the field to validate.
     * @param attribute - The validation attributes to apply.
     * @returns An array of `ValidationErrorContext` objects describing the validation errors.
     */
    static validateProperty(field, value, attribute) {
        const validationErrorContexts = [];
        if (value == null) {
            return validationErrorContexts;
        }
        if (typeof value === 'string') {
            if (attribute.maxLength !== undefined && value.length > attribute.maxLength) {
                validationErrorContexts.push({ field, message: `must be at most ${attribute.maxLength} characters long` });
            }
            if (attribute.minLength !== undefined && value.length < attribute.minLength) {
                validationErrorContexts.push({ field, message: `must be at least ${attribute.minLength} characters long` });
            }
            if (attribute.pattern && !attribute.pattern.test(value)) {
                validationErrorContexts.push({ field, message: 'must match required pattern' });
            }
            if (attribute.maxDate && attribute.maxDate === 'week') {
                try {
                    // Create current date in Jakarta timezone (GMT+7)
                    const currentDate = new Date();
                    // Add 7 hours to get Jakarta time
                    currentDate.setHours(currentDate.getHours() + 7);
                    // Maximum allowed date (current date + 7 days)
                    const maxDate = new Date(currentDate);
                    maxDate.setDate(maxDate.getDate() + 7);
                    // Parse the input date (assuming it's in ISO 8601 format)
                    const inputDate = new Date(value);
                    // Check if the input date exceeds the maximum allowed date
                    if (inputDate > maxDate) {
                        validationErrorContexts.push({
                            field,
                            message: 'date cannot be more than one week in the future'
                        });
                    }
                }
                catch (error) {
                    validationErrorContexts.push({
                        field,
                        message: 'invalid date format'
                    });
                }
            }
        }
        if (typeof value === 'number') {
            if (attribute.maximum !== undefined && value > attribute.maximum) {
                validationErrorContexts.push({ field, message: `must be less than or equal to ${attribute.maximum}` });
            }
            if (attribute.exclusiveMaximum && value >= attribute.maximum) {
                validationErrorContexts.push({ field, message: `must be less than ${attribute.maximum}` });
            }
            if (attribute.minimum !== undefined && value < attribute.minimum) {
                validationErrorContexts.push({ field, message: `must be greater than or equal to ${attribute.minimum}` });
            }
            if (attribute.exclusiveMinimum && value <= attribute.minimum) {
                validationErrorContexts.push({ field, message: `must be greater than ${attribute.minimum}` });
            }
            if (attribute.multipleOf !== undefined && value % attribute.multipleOf !== 0) {
                validationErrorContexts.push({ field, message: `must be a multiple of ${attribute.multipleOf}` });
            }
        }
        if (Array.isArray(value)) {
            if (attribute.maxItems !== undefined && value.length > attribute.maxItems) {
                validationErrorContexts.push({ field, message: `must have at most ${attribute.maxItems} items` });
            }
            if (attribute.minItems !== undefined && value.length < attribute.minItems) {
                validationErrorContexts.push({ field, message: `must have at least ${attribute.minItems} items` });
            }
            if (attribute.uniqueItems) {
                const unique = new Set(value);
                if (unique.size !== value.length) {
                    validationErrorContexts.push({ field, message: 'must have unique items' });
                }
            }
        }
        return validationErrorContexts;
    }
    static getValidationErrorMessage(validationErrorContexts) {
        return validationErrorContexts.map((validationErrorContext) => {
            return `${validationErrorContext.field} ${validationErrorContext.message}`;
        }).join(', ');
    }
}
exports.ValidationUtil = ValidationUtil;
class DanaHeaderUtil {
    /**
     * Populates the HTTP headers required for the Snap B2B scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param httpMethod - The HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as a string.
     * @param privateKey - The private key used for generating the signature.
     * @param origin - The origin of the request.
     * @param partnerId - The partner ID.
     */
    static populateSnapB2BScenarioHeader(headerParameters, httpMethod, endpointUrl, requestBody, privateKey, origin, partnerId, debugMode) {
        const timestamp = (0, date_fns_tz_1.format)(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        const signature = DanaSignatureUtil.generateSnapB2BScenarioSignature(httpMethod, endpointUrl, requestBody, privateKey, timestamp);
        headerParameters['X-TIMESTAMP'] = timestamp;
        headerParameters['X-SIGNATURE'] = signature;
        headerParameters['ORIGIN'] = origin;
        headerParameters['X-PARTNER-ID'] = partnerId;
        headerParameters['X-EXTERNAL-ID'] = 'sdk' + (0, uuid_1.v4)().substring(3);
        headerParameters['CHANNEL-ID'] = partnerId + '-SERVER';
        if (debugMode) {
            headerParameters['X-Debug-Mode'] = 'true';
        }
    }
    /**
     * Populates the HTTP headers required for the Snap B2B scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param httpMethod - The HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as object
     * @param privateKey - The private key used for generating the signature.
     * @param clientSecret - The client secret used for generating the signature.
     * @param partnerId - The partner ID.
     * @param functionName - The function name.
     */
    static populateOpenApiScenarioHeader(headerParameters, httpMethod, endpointUrl, requestBody, privateKey, clientSecret, partnerId, functionName) {
        const timestamp = (0, date_fns_tz_1.format)(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        requestBody['request']['head'] = {
            'version': "2.0",
            'function': functionName,
            'clientId': partnerId,
            'clientSecret': clientSecret,
            'reqTime': timestamp,
            'reqMsgId': 'sdk' + (0, uuid_1.v4)().substring(3),
            'reserve': {}
        };
        const signature = DanaSignatureUtil.generateOpenApiScenarioSignature(privateKey, JSON.stringify(requestBody["request"]));
        requestBody['signature'] = signature;
    }
    /**
     * Populates the HTTP headers required for the Snap Apply Token scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param privateKey - The private key used for generating the signature.
     * @param partnerId - The partner ID.
     */
    static populateSnapApplyTokenScenarioHeader(headerParameters, privateKey, partnerId) {
        const timestamp = (0, date_fns_tz_1.format)(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        const signature = DanaSignatureUtil.generateSnapApplyTokenScenarioSignature(partnerId, privateKey, timestamp);
        headerParameters['X-TIMESTAMP'] = timestamp;
        headerParameters['X-CLIENT-KEY'] = partnerId;
        headerParameters['X-SIGNATURE'] = signature;
    }
    /**
     * Populates the HTTP headers required for the Snap Account B2B2C scenario.
     * @param headerParameters - The HTTP headers object to populate.
     * @param httpMethod - The HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as a string.
     * @param privateKey - The private key used for generating the signature.
     * @param origin - The origin of the request.
     * @param partnerId - The partner ID.
     * @param accessToken - The access token.
     * @param endUserIpAddress - The end user IP address.
     * @param deviceId - The device ID.
     * @param latitude - The latitude.
     * @param longitude - The longitude.
     */
    static populateSnapAccountB2B2CScenarioHeader(headerParameters, httpMethod, endpointUrl, requestBody, privateKey, origin, partnerId, accessToken, endUserIpAddress, deviceId, latitude, longitude) {
        const timestamp = (0, date_fns_tz_1.format)(new Date(), "yyyy-MM-dd'T'HH:mm:ssXXX");
        const signature = DanaSignatureUtil.generateSnapB2BScenarioSignature(httpMethod, endpointUrl, requestBody, privateKey, timestamp);
        headerParameters['Authorization-Customer'] = accessToken.startsWith('Bearer ') ? accessToken : `Bearer ${accessToken}`;
        headerParameters['X-TIMESTAMP'] = timestamp;
        headerParameters['X-SIGNATURE'] = signature;
        headerParameters['ORIGIN'] = origin;
        headerParameters['X-PARTNER-ID'] = partnerId;
        headerParameters['X-EXTERNAL-ID'] = 'sdk' + (0, uuid_1.v4)().substring(3);
        headerParameters['X-IP-ADDRESS'] = endUserIpAddress;
        headerParameters['X-DEVICE-ID'] = deviceId;
        headerParameters['X-LATITUDE'] = latitude;
        headerParameters['X-LONGITUDE'] = longitude;
        headerParameters['CHANNEL-ID'] = partnerId + '-SERVER';
    }
}
exports.DanaHeaderUtil = DanaHeaderUtil;
class DanaSignatureUtil {
    /**
     * Generates a signature for the Snap B2B scenario.
     * @param httpMethod - HTTP method (e.g., GET, POST).
     * @param endpointUrl - The API endpoint URL.
     * @param requestBody - The request body as a string.
     * @param privateKey - The private key used for generating the signature.
     * @param timestamp - The timestamp for the signature.
     * @returns The Base64-encoded signature.
     */
    static generateSnapB2BScenarioSignature(httpMethod, endpointUrl, requestBody, privateKey, timestamp) {
        // Generate a SHA-256 hash of the request body
        const hash = (0, node_crypto_1.createHash)('sha256')
            .update(requestBody)
            .digest('hex');
        // Construct the string to sign
        const stringToSign = `${httpMethod}:${endpointUrl}:${hash}:${timestamp}`;
        return this.generateAsymmetricSignature(stringToSign, privateKey);
    }
    /**
     * Generates a signature for the Snap Apply Token scenario.
     * @param partnerId - The partner ID.
     * @param privateKey - The private key used for generating the signature.
     * @param timestamp - The timestamp for the signature.
     * @returns The Base64-encoded signature.
     */
    static generateSnapApplyTokenScenarioSignature(partnerId, privateKey, timestamp) {
        // Construct the string to sign
        const stringToSign = `${partnerId}|${timestamp}`;
        return this.generateAsymmetricSignature(stringToSign, privateKey);
    }
    static generateOpenApiScenarioSignature(privateKey, requestBody) {
        return this.generateAsymmetricSignature(requestBody, privateKey);
    }
    /**
     * Generates the seamlessSign for Oauth Url
     * @param seamlessData The data object to be signed
     * @param privateKey The private key for signing
     * @returns URL-encoded signature string
     */
    static generateSeamlessSign(seamlessData, privateKey) {
        if (!seamlessData) {
            return '';
        }
        if (!privateKey) {
            throw new RequiredError('generateSeamlessSign', 'Private key is required');
        }
        try {
            const seamlessDataStr = JSON.stringify(seamlessData);
            const signer = (0, node_crypto_1.createSign)('RSA-SHA256');
            signer.update(seamlessDataStr);
            const signature = signer.sign({
                key: this.convertToPEM(privateKey, 'PRIVATE'),
                padding: node_crypto_1.constants.RSA_PKCS1_PADDING,
            });
            const base64Signature = signature.toString('base64');
            return encodeURIComponent(base64Signature);
        }
        catch (error) {
            throw new Error(`Failed to calculate seamlessSign: ${error.message}`);
        }
    }
    /**
     * Generates an asymmetric signature.
     * @param stringToSign - The string to sign.
     * @param privateKey - The private key used for generating the signature.
     * @returns The Base64-encoded signature.
     */
    static generateAsymmetricSignature(stringToSign, privateKey) {
        // Create an RSA-SHA256 signer and sign the string
        const sign = (0, node_crypto_1.createSign)('RSA-SHA256');
        sign.update(stringToSign);
        sign.end();
        // Convert the private key to PEM format and sign the string
        const pemKey = this.convertToPEM(privateKey, 'PRIVATE');
        return sign.sign(pemKey, 'base64');
    }
    /**
     * Converts a private/public key to PEM format.
     * @param key - The key.
     * @param keyType - The type of key (e.g., PRIVATE, PUBLIC).
     * @returns The PEM-formatted key.
     */
    static convertToPEM(key, keyType) {
        const header = `-----BEGIN ${keyType} KEY-----`;
        const footer = `-----END ${keyType} KEY-----`;
        const delimiter = '\n';
        // Check if the key is already in PEM format
        if (key.includes(header) && key.includes(footer)) {
            return key.replace(/\\n/g, delimiter);
        }
        key = key.replace(/\\n/g, '');
        const chunks = [];
        for (let i = 0; i < key.length; i += 64) {
            const end = Math.min(i + 64, key.length);
            chunks.push(key.slice(i, end));
        }
        const body = chunks.join(delimiter);
        return header + delimiter + body + delimiter + footer;
    }
    /**
     * Splits a string into chunks of a specified size.
     * @param input - The input string.
     * @param chunkSize - The size of each chunk.
     * @returns An array of string chunks.
     */
    static splitStringIntoChunks(input, chunkSize) {
        const chunks = [];
        for (let i = 0; i < input.length; i += chunkSize) {
            chunks.push(input.slice(i, i + chunkSize));
        }
        return chunks;
    }
}
exports.DanaSignatureUtil = DanaSignatureUtil;
